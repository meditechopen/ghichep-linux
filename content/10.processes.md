# Processes## Các tiến trình LinuxMột quy trình chỉ đơn giản là một thể hiện của một hoặc nhiều tác vụ liên quan ( chủ đề ) đang thực hiện trên cùng một máy. Nó không giống như một chương trình hoặc một lệnh; Một chương trình duy nhất có thể thực sự bắt đầu một số quy trình cùng một lúc. Một số quy trình độc lập với nhau và các quy trình khác có liên quan. Sự thất bại của một quá trình có thể hoặc không thể ảnh hưởng đến những người khác đang chạy trên hệ thống. Các quy trình sử dụng nhiều tài nguyên hệ thống, chẳng hạn như bộ nhớ, chu kỳ CPU và các thiết bị ngoại vi như máy in và màn hình. Hệ điều hành (đặc biệt là hạt nhân) có trách nhiệm bố trí đúng chia sẻ các nguồn lực này cho từng quy trình và đảm bảo sử dụng tối ưu một cách toàn diện.Một cửa sổ thiết bị đầu cuối là một quá trình chạy càng lâu càng tốt. Nó cho phép người dùng thực hiện các chương trình và truy cập tài nguyên trong một môi trường tương tác. Bạn cũng có thể chạy các chương trình trong nền, có nghĩa là chúng được tách ra khỏi trình bao. Các quy trình có thể được các loại khác nhau theo nhiệm vụ đang được thực hiện.|Type|Description||--------|---------||Interactive|Cần phải được bắt đầu bởi một người dùng, hoặc là tại một dòng lệnh hoặc thông qua một giao diện đồ họa như một biểu tượng hoặc một lựa chọn menu.||Batch|Các quy trình tự động được lên kế hoạch từ và sau đó bị ngắt kết nối khỏi thiết bị đầu cuối. Các nhiệm vụ này được xếp hàng đợi và làm việc trên cơ sở FIFO (First In, First Out).||Daemons|Các quy trình máy chủ chạy liên tục. Nhiều chương trình được khởi chạy trong quá trình khởi động hệ thống và chờ đợi yêu cầu của người dùng hoặc hệ thống cho biết rằng dịch vụ của họ là bắt buộc.||Threads|Quy trình nhẹ. Đây là những nhiệm vụ chạy dưới sự che chở của một quy trình chính, chia sẻ bộ nhớ và các tài nguyên khác, nhưng được lập kế hoạch và điều hành bởi hệ thống trên cơ sở cá nhân.||Kernel Threads|Nhiệm vụ hạt nhân mà người dùng không bắt đầu cũng không chấm dứt và có ít quyền kiểm soát. Các lệnh này có thể thực hiện các hành động như di chuyển một luồng từ một CPU này sang một bộ xử lý khác hoặc đảm bảo hoạt động đầu vào / đầu ra trên đĩa đã hoàn thành.|Khi quá trình đang ở trạng thái đang chạy , nó có nghĩa là nó hiện đang thực hiện các hướng dẫn trên CPU, hoặc đang chờ chia sẻ (hoặc slice thời gian) để nó có thể chạy. Một thói quen hạt nhân quan trọng được gọi là scheduler liên tục thay đổi các quy trình trong và ngoài của CPU, chia sẻ thời gian theo mức độ ưu tiên tương đối, cần bao nhiêu thời gian và mức độ đã được cấp cho một nhiệm vụ. Tất cả các quy trình trong tiểu bang này nằm trên một hàng đợi chạy và trên một máy tính có nhiều CPU có một hàng đợi chạy trên mỗi máy. Đôi khi các quy trình đi vào trạng thái ngủ , thông thường khi họ đang chờ đợi điều gì đó xảy ra trước khi họ có thể tiếp tục, có lẽ cho người dùng gõ một cái gì đó. Trong điều kiện này một quá trình đang ngồi trong một hàng đợi chờ đợi. Có một số tiểu bang quá trình ít thường xuyên hơn, Đặc biệt là khi một quá trình chấm dứt. Đôi khi một quy trình con hoàn thành nhưng quá trình cha mẹ của nó đã không hỏi về trạng thái của nó. Một quá trình như vậy được cho là trong một trạng thái zombie ; Nó không thực sự còn sống  mà vẫn hiển thị trong danh sách các quy trình của hệ thống.Tại bất kỳ thời điểm nào đó luôn luôn có nhiều quá trình đang được thực hiện. Hệ điều hành theo dõi chúng bằng cách gán cho mỗi ID quy trình hoặc số PID duy nhất . PID được sử dụng để theo dõi quá trình sử dụng CPU, sử dụng bộ nhớ, chính xác các tài nguyên nằm trong bộ nhớ và các đặc tính khác. Các PIDs mới thường được chỉ định theo thứ tự tăng dần khi các quá trình được sinh ra. Như vậy PID 1 biểu thị tiến trình init (quá trình khởi tạo ), và các quá trình thành công được phân bổ dần dần.Tại bất kỳ thời điểm nào, nhiều quá trình đang chạy trên hệ thống. Tuy nhiên, một CPU thực sự chỉ có thể chứa một nhiệm vụ một lúc, giống như một chiếc xe chỉ có thể có một trình điều khiển cùng một lúc. Một số quy trình quan trọng hơn những quy trình khác vì vậy Linux cho phép bạn thiết lập và vận dụng ưu tiên quá trình. Quá trình ưu tiên cao hơn được dành nhiều thời gian hơn cho bộ xử lý. Các ưu tiên cho một quá trình có thể được thiết lập bằng cách xác định một giá trị nice cho quá trình này. Giá trị nice hơn càng thấp thì mức độ ưu tiên càng cao. Giá trị thấp được gán cho các quá trình quan trọng, trong khi các giá trị cao được gán cho các quá trình có thể chờ lâu hơn. Một quá trình với một giá trị nice chỉ đơn giản là cho phép các quá trình khác được thực hiện trước tiên. Trong Linux, một giá trị nice -20 đại diện cho mức độ ưu tiên cao nhất và 19 là thấp nhất. Bạn cũng có thể chỉ định thời gian thực cho các tác vụ nhạy cảm với thời gian, chẳng hạn như kiểm soát máy móc hoặc thu thập dữ liệu đến. Đây chỉ là một ưu tiên rất cao và không được nhầm lẫn với những gì được gọi là thời gian thực khó khăn khác biệt khái niệm, và có nhiều liên quan đến việc đảm bảo một công việc được hoàn thành trong một cửa sổ thời gian rất tốt được xác định.## Các tiến trình đang chạyCác lệnh ps cung cấp thông tin về tiến trình đang chạy, keyed bởi PID . Nếu bạn muốn cập nhật lại trạng thái này, bạn có thể sử dụng lệnh top hoặc biến thể được cài đặt thông thường như htop hoặc atoptừ dòng lệnh. Các lệnh ps có nhiều lựa chọn để xác định chính xác những nhiệm vụ để kiểm tra, những thông tin nào để hiển thị về họ, và chính xác những gì định dạng đầu ra nên được sử dụng.Nếu không có tùy chọn, ps sẽ hiển thị tất cả các quy trình chạy hiện tại. Bạn có thể sử dụng ps -u để hiển thị thông tin về quá trình cho một tên người dùng được chỉ định. Lệnh ps -ef hiển thị toàn bộ các quy trình trong hệ thống. Lệnh ps -elf đi một bước xa hơn và hiển thị một dòng thông tin cho mỗi luồng (một tiến trình có thể chứa nhiều luồng).```sh root@server:~# ps -u root   PID TTY          TIME CMD     1 ?        00:00:01 init     2 ?        00:00:00 kthreadd     3 ?        00:00:00 ksoftirqd/0     4 ?        00:00:00 kworker/0:0     5 ?        00:00:00 kworker/0:0H     6 ?        00:00:00 kworker/u256:0     7 ?        00:00:00 rcu_sched     8 ?        00:00:00 rcu_bh     9 ?        00:00:00 rcuos/0```Các lệnh pstree hiển thị các tiến trình đang chạy trên hệ thống dưới dạng một sơ đồ cây thể hiện mối quan hệ giữa một quá trình và quá trình cha mẹ và toàn bộ các quá trình khác mà nó tạo ra. Mục nhập lặp lại của một quá trình không được hiển thị, và các luồng được hiển thị bằng dấu ngoặc nhọn.```shroot@server:~# pstreeinit─┬─acpid     ├─apache2───5*[apache2]     ├─atd     ├─cron     ├─dbus-daemon     ├─6*[getty]     ├─mysqld───43*[{mysqld}]     ├─rsyslogd───3*[{rsyslogd}]     ├─snmpd     ├─sshd─┬─sshd───bash───pstree     │      └─sshd───sftp-server     ├─systemd-logind     ├─systemd-udevd     ├─upstart-file-br     ├─upstart-socket-     ├─upstart-udev-br     ├─zabbix_agentd───5*[zabbix_agentd]     └─zabbix_server───26*[zabbix_server]```Để chấm dứt một quá trình bạn có thể gõ kill -SIGKILL <pid>hoặc kill -9 <pid>. Lưu ý tuy nhiên, bạn chỉ có thể giết các quy trình của riêng bạn: những người thuộc một người dùng khác bị giới hạn trừ khi bạn là root.Một lựa chọn tốt hơn là sử dụng topđể nhận được cập nhật liên tục thời gian (mỗi hai giây theo mặc định). Các lệnh top rõ ràng nêu bật mà các quá trình đang tiêu thụ hầu hết các chu kỳ CPU và bộ nhớ.```shTasks: 183 total,   2 running, 181 sleeping,   0 stopped,   0 zombie%Cpu(s):  0.3 us,  2.9 sy,  0.0 ni, 96.4 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 stKiB Mem:    999028 total,   776588 used,   222440 free,    25376 buffersKiB Swap:  1044476 total,        0 used,  1044476 free.   141252 cached Mem   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND  1065 mysql     20   0 1340568 484268  14232 S  0.7 48.5   0:02.80 mysqld    29 root      20   0       0      0      0 S  0.3  0.0   0:01.22 kworker/0:1     1 root      20   0   33364   3840   2616 S  0.0  0.4   0:01.68 init     2 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kthreadd     3 root      20   0       0      0      0 S  0.0  0.0   0:00.01 ksoftirqd/0     5 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 kworker/0:0H     7 root      20   0       0      0      0 S  0.0  0.0   0:00.06 rcu_sched     8 root      20   0       0      0      0 S  0.0  0.0   0:00.00 rcu_bh     9 root      20   0       0      0      0 R  0.0  0.0   0:00.06 rcuos/0    10 root      20   0       0      0      0 S  0.0  0.0   0:00.00 rcuob/0    11 root      rt   0       0      0      0 S  0.0  0.0   0:00.00 migration/0    12 root      rt   0       0      0      0 S  0.0  0.0   0:00.00 watchdog/0    13 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 khelper    14 root      20   0       0      0      0 S  0.0  0.0   0:00.00 kdevtmpfs    15 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 netns    16 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 perf    17 root      20   0       0      0      0 S  0.0  0.0   0:00.00 khungtaskd    18 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 writeback    19 root      25   5       0      0      0 S  0.0  0.0   0:00.00 ksmd    20 root      39  19       0      0      0 S  0.0  0.0   0:00.94 khugepaged    21 root       0 -20       0      0      0 S  0.0  0.0   0:00.00 crypto```Dòng đầu tiên của topđầu ra hiển thị một bản tóm tắt nhanh về những gì đang xảy ra trong hệ thống bao gồm:- Hệ thống đã được bật lên bao lâu - Có bao nhiêu người dùng đăng nhập - Tải trung bình Trung bình tải xác định mức độ bận rộn của hệ thống. Tải trọng trung bình là 1.00 cho mỗi CPU chỉ ra rằng đã đăng ký đầy đủ, nhưng không quá tải, hệ thống. Nếu tải trung bình vượt quá giá trị này, nó chỉ ra rằng các quá trình đang cạnh tranh cho thời gian CPU. Nếu tải trọng trung bình rất cao, có thể chỉ ra rằng hệ thống đang gặp sự cố, chẳng hạn như quy trình chạy trốn (quá trình ở trạng thái không phản hồi).Dòng thứ hai của top đầu ra hiển thị tổng số tiến trình, số lượng các tiến trình chạy, ngủ, dừng và zombie. So sánh số tiến trình đang chạy với mức trung bình tải giúp xác định xem hệ thống đã đạt đến dung lượng của nó hoặc có thể một người dùng cụ thể đang chạy quá nhiều quy trình. Các quy trình dừng phải được kiểm tra để xem mọi thứ có đang chạy đúng hay không.Dòng thứ ba của topđầu ra cho biết thời gian CPU được chia giữa người dùng ( us ) và hạt nhân ( sy ) bằng cách hiển thị phần trăm thời gian của CPU được sử dụng cho mỗi. Phần trăm của các công việc người dùng chạy ở mức ưu tiên thấp hơn ( ni ) sau đó được liệt kê. Chế độ nhàn rỗi ( id ) nên thấp nếu tải trọng trung bình cao và ngược lại. Phần trăm công việc chờ đợi ( wa ) cho I / O được liệt kê. Ngắt bao gồm phần trăm phần cứng ( hi ) so với ngắt phần mềm ( si ). Ăn cắp thời gian ( st ) thường được sử dụng với các máy ảo, trong đó có một số thời gian CPU nhàn rỗi của mình chụp cho các mục đích khác.Dòng thứ tư và thứ năm của topđầu ra cho biết sử dụng bộ nhớ, được chia thành hai loại:- Bộ nhớ vật lý (RAM): hiển thị trên dòng 4.- Trao đổi không gian: hiển thị trên dòng 5.- Cả hai loại hiển thị tổng bộ nhớ, bộ nhớ đã sử dụng, và không gian trống.Bạn cần theo dõi việc sử dụng bộ nhớ rất cẩn thận để đảm bảo hiệu năng hệ thống tốt. Một khi bộ nhớ vật lý đã cạn kiệt, hệ thống sẽ bắt đầu sử dụng không gian trao đổi như là một bộ nhớ mở rộng, và vì việc truy cập đĩa chậm hơn nhiều so với việc truy cập vào bộ nhớ, điều này sẽ ảnh hưởng tiêu cực đến hiệu năng của hệ thống. Nếu hệ thống bắt đầu sử dụng trao đổi thường xuyên, bạn có thể thêm không gian hoán đổi nhiều hơn nữa. Tuy nhiên, thêm nhiều bộ nhớ vật lý cũng nên được xem xét.Mỗi dòng trong danh sách quá trình của topđầu ra hiển thị thông tin về một quy trình. Theo mặc định, các quy trình được sắp xếp theo cách sử dụng CPU cao nhất. Các thông tin sau về mỗi quá trình được hiển thị:- Số nhận dạng quá trình (PID)- Chủ sở hữu quy trình (USER)- Ưu tiên (PR) và các giá trị tốt đẹp (NI)- Virtual (VIRT), vật lý (RES) và bộ nhớ chia sẻ (SHR)- Trạng thái (S)- Phần trăm CPU (% CPU) và bộ nhớ (% MEM) đã sử dụng- Thời gian thực hiện (TIME +)- Lệnh (COMMAND)Để kiểm soát sự hồi phục của một hệ thống, tải trọng trung bình của hệ thống nên được kiểm tra đầu tiên. Giả sử hệ thống của chúng tôi là một hệ thống đơn CPU, 0,25 có nghĩa là cho phút vừa qua, trung bình, hệ thống đã được sử dụng 25%. 0.12 ở vị trí tiếp theo nghĩa là trong 5 phút vừa qua, trung bình hệ thống đã được sử dụng 12%; Và 0,15 ở vị trí cuối cùng có nghĩa là trong 15 phút vừa qua, trung bình, hệ thống đã được sử dụng 15%. Nếu chúng ta thấy giá trị 1,00 ở vị trí thứ hai, có nghĩa là hệ thống CPU đơn được sử dụng 100% trong trung bình 5 phút qua; Điều này là tốt nếu chúng ta muốn sử dụng một hệ thống hoàn chỉnh. Một giá trị trên 1.00 cho một hệ thống đơn CPU ngụ ý rằng hệ thống đã được sử dụng quá mức: có nhiều quá trình cần CPU hơn CPU đã có sẵn. Nếu chúng ta có nhiều hơn một CPU, nói một hệ thống quad-CPU, Chúng ta sẽ chia số tải trung bình cho số lượng CPU. Trong trường hợp này, ví dụ: thấy trung bình tải trong 1 phút là 4,00 nghĩa là toàn bộ hệ thống là 100% (4,00 / 4) được sử dụng trong phút chót. Tăng ngắn hạn thường không phải là một vấn đề. Một đỉnh cao mà bạn nhìn thấy có thể là một sự bùng nổ của hoạt động chứ không phải là một cấp độ mới. Ví dụ, khi bắt đầu, nhiều quá trình bắt đầu và sau đó hoạt động giải quyết xuống. Nếu một đỉnh cao được thấy trong trung bình tải 5 và 15 phút, nó có thể gây ra mối quan tâm. Nhiều quá trình bắt đầu và sau đó hoạt động giải quyết xuống. Nếu một đỉnh cao được thấy trong trung bình tải 5 và 15 phút, nó có thể gây ra mối quan tâm. Nhiều quá trình bắt đầu và sau đó hoạt động giải quyết xuống. Nếu một đỉnh cao được thấy trong trung bình tải 5 và 15 phút, nó có thể gây ra mối quan tâm.Linux hỗ trợ nền và foreground xử lý công việc. Các công việc Foreground chạy trực tiếp từ shell, và khi một công việc foreground đang chạy, các công việc khác cần phải đợi cho đến khi nó được hoàn thành. Điều này tốt khi công việc hoàn thành nhanh chóng. Nhưng điều này có thể có tác động bất lợi nếu công việc hiện tại sẽ mất một thời gian dài để hoàn thành. Trong những trường hợp như vậy, bạn có thể chạy công việc trong nền và giải phóng trình bao cho các tác vụ khác. Công việc nền sẽ được thực hiện ở mức ưu tiên thấp hơn, và sẽ cho phép thực hiện các tác vụ tương tác trơn tru và bạn có thể gõ các lệnh khác trong cửa sổ terminal trong khi công việc nền đang chạy. Theo mặc định tất cả các công việc được thực hiện ở tiền cảnh. Điều này Bạn có thể đặt một công việc trong nền:```sh# updatedb &[1] 7437# jobs[1]+  Done                    updatedb#```## Quá trình lập kế hoạch## Các quá trình trì hoãnĐôi khi lệnh hoặc công việc phải hoãn hoặc đình chỉ. Giả sử, ví dụ một ứng dụng đã đọc và xử lý nội dung của một tệp dữ liệu và sau đó cần lưu một báo cáo về một hệ thống sao lưu. Nếu hệ thống sao lưu hiện đang bận hoặc không có sẵn, ứng dụng có thể được thực hiện để ngủ cho đến khi nó có thể hoàn thành công việc của nó. Sự chậm trễ như vậy có thể là gắn thiết bị sao lưu và chuẩn bị cho việc viết. Các sleeplệnh đình chỉ thực hiện trong ít nhất thời gian nhất định, có thể được đưa ra là số giây (mặc định), phút, giờ hoặc vài ngày. Sau thời gian đó, việc thực hiện sẽ tiếp tục.```sh# vi script.sh#!/bin/bashecho "The system will go to sleep fo 30 seconds ..."sleep 15echo "The system is awaked"# chmod u+x script.sh# ./script.shThe system will go to sleep fo 30 seconds ...The system is awaked#```